import * as fs from 'fs/promises'
import * as path from 'path'
import { fileURLToPath } from 'url'
// eslint-disable-next-line import/no-extraneous-dependencies
import * as devalue from 'devalue'
import {
  type EncodingName,
  type ModelName,
  chatModelParams,
  DEFAULT_ENCODING,
  modelToEncodingMap,
} from '../mapping.js'
import type { Feature } from '../modelTypes.js'
import * as models from '../models.js'

// eslint-disable-next-line no-underscore-dangle
const __dirname = path.dirname(fileURLToPath(import.meta.url))

const directivePrefixes = [
  '/* eslint-disable',
  '// eslint-disable',
  '// @ts-nocheck',
  '// prettier-ignore',
] as const

const insertHeaderAfterDirectives = (
  content: string,
  headerLines: string[],
): string => {
  const lines = content.split('\n')
  let insertIndex = 0

  while (insertIndex < lines.length) {
    const line = lines[insertIndex]!

    if (directivePrefixes.some((prefix) => line.startsWith(prefix))) {
      insertIndex += 1
      // eslint-disable-next-line no-continue
      continue
    }

    break
  }

  lines.splice(insertIndex, 0, ...headerLines)
  return lines.join('\n')
}

const chatModels = Object.keys(chatModelParams)

const encodingBpeOverrides: Partial<Record<EncodingName, string>> = {
  o200k_harmony: 'o200k_base',
}

const template = await fs.readFile(
  path.join(__dirname, '../encoding/cl100k_base.ts'),
  'utf8',
)

await fs.mkdir(path.join(__dirname, '../model'), { recursive: true })
await Promise.all(
  Object.entries(models).map(async ([_modelName, modelData]) => {
    const modelName = _modelName as ModelName
    const encoding = modelToEncodingMap[modelName] ?? DEFAULT_ENCODING
    const isChatModel = chatModels.includes(modelName)
    const bpeModuleName = encodingBpeOverrides[encoding] ?? encoding

    const headerLines = [
      '// This file was generated by src/codegen/generateByModel.ts.',
      '// To regenerate, run: yarn codegen:models.',
      `// Source template: src/encoding/${encoding}.ts.`,
      '',
    ]

    const supportedFeatures = (
      modelData as { supported_features?: readonly Feature[] }
    ).supported_features

    const supportsFunctionCalling =
      Array.isArray(supportedFeatures) &&
      supportedFeatures.includes('function_calling')

    let baseContent = isChatModel
      ? template
          .replace(
            `getEncodingApi('cl100k_base', () => bpeRanks)`,
            `getEncodingApiForModel('${modelName}', () => bpeRanks, ${devalue.uneval(
              modelData,
            )})`,
          )
          .replace('\nconst api =', '// prettier-ignore\nconst api =')
          .replaceAll(
            '../bpeRanks/cl100k_base.js',
            `../bpeRanks/${bpeModuleName}.js`,
          )
          .replaceAll(`encoding/cl100k_base`, `encoding/${encoding}`)
      : /* ts */ `// eslint-disable-next-line no-restricted-exports, import/no-default-export
export { default } from '../encoding/${encoding}.js'
export * from '../encoding/${encoding}.js'
`

    if (isChatModel && supportsFunctionCalling) {
      const snippet = '  encodeChat,\n  encodeChatGenerator,\n'
      const replacement =
        '  encodeChat,\n  countChatCompletionTokens,\n  encodeChatGenerator,\n'
      baseContent = baseContent.replace(snippet, replacement)
      baseContent = baseContent.replace(snippet, replacement)
    }

    const content = insertHeaderAfterDirectives(baseContent, headerLines)
    await fs.writeFile(
      path.join(__dirname, `../model/${modelName}.ts`),
      content,
    )

    // eslint-disable-next-line no-console
    console.log(`wrote encoding/${modelName}.ts`)
  }),
)
